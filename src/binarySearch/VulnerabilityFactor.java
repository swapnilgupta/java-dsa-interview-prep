package binarySearch;

import java.util.List;

public class VulnerabilityFactor {
  public static int findVulnerabilityFactor(List<Integer> key, int maxChange) {
    int n = key.size();
    int[] arr = key.stream().mapToInt(Integer::intValue).toArray();

    // Binary search on the answer
    int left = 1, right = n, ans = n;

    while (left <= right) {
      int mid = (left + right) / 2;
      if (canAchieveMaxLength(arr, maxChange, mid)) {
        ans = mid;
        right = mid - 1; // try smaller
      } else {
        left = mid + 1; // need larger
      }
    }
    return ans;
  }

  // Efficient approach: check if we can break all bad subarrays of length > maxLen
  private static boolean canAchieveMaxLength(int[] arr, int maxChange, int maxLen) {
    int n = arr.length;
    if (maxLen >= n) return true;
    
    int changes = 0;
    
    // Check all subarrays of length exactly (maxLen + 1)
    // If any has GCD > 1, we must break it with a change
    for (int i = 0; i <= n - maxLen - 1; i++) {
      if (subarrayHasGcdGreaterThanOne(arr, i, i + maxLen)) {
        changes++;
        if (changes > maxChange) {
          return false;
        }
        // Greedy: assume we change arr[i + maxLen] to 1
        // This breaks all subarrays ending at or before i + maxLen
        // So we can skip ahead
        i += maxLen;
      }
    }
    
    return true;
  }
  
  // Optimized GCD check with multiple early terminations
  private static boolean subarrayHasGcdGreaterThanOne(int[] arr, int start, int end) {
    if (start > end) return false;
    if (start == end) return arr[start] > 1;
    
    // Quick check: if any element is 1, GCD will be 1
    for (int i = start; i <= end; i++) {
      if (arr[i] == 1) return false;
    }
    
    // Now compute GCD knowing no element is 1
    int currentGcd = arr[start];
    for (int i = start + 1; i <= end && currentGcd > 1; i++) {
      currentGcd = gcd(currentGcd, arr[i]);
    }
    
    return currentGcd > 1;
  }
  
  // Fastest GCD using binary GCD (Stein's algorithm) with optimizations
  private static int gcd(int a, int b) {
    // Handle edge cases quickly
    if (a == b) return a;
    if (a == 0) return b;
    if (b == 0) return a;
    if (a == 1 || b == 1) return 1;
    
    // Make a >= b
    if (a < b) {
      int temp = a;
      a = b;
      b = temp;
    }
    
    // Binary GCD (Stein's algorithm) - faster than Euclidean for large numbers
    int shift = 0;
    
    // Factor out powers of 2
    while (((a | b) & 1) == 0) {
      a >>= 1;
      b >>= 1;
      shift++;
    }
    
    // Remove all factors of 2 from a
    while ((a & 1) == 0) {
      a >>= 1;
    }
    
    while (b != 0) {
      // Remove all factors of 2 from b
      while ((b & 1) == 0) {
        b >>= 1;
      }
      
      // Ensure a >= b
      if (a > b) {
        int temp = a;
        a = b;
        b = temp;
      }
      
      b = b - a;
    }
    
    return a << shift;
  }

  public static void main(String[] args) {
    List<Integer> key = List.of(5, 10, 20, 10, 15, 5);
    int maxChange = 2;
    System.out.println(findVulnerabilityFactor(key, maxChange));
  }
}
